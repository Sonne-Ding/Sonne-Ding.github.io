<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://sonne-ding.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://sonne-ding.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-08-27T07:06:02+00:00</updated><id>https://sonne-ding.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">Ubuntu22.04安装rime+雾凇输入法+美化，实现跟微软拼音一样的使用体验(基于Flatpak) - dingyang</title><link href="https://sonne-ding.github.io/blog/2025/ubuntu2204rimeflatpak-dingyang/" rel="alternate" type="text/html" title="Ubuntu22.04安装rime+雾凇输入法+美化，实现跟微软拼音一样的使用体验(基于Flatpak) - dingyang"/><published>2025-07-26T08:52:00+00:00</published><updated>2025-07-26T08:52:00+00:00</updated><id>https://sonne-ding.github.io/blog/2025/ubuntu2204rimeflatpak---dingyang</id><content type="html" xml:base="https://sonne-ding.github.io/blog/2025/ubuntu2204rimeflatpak-dingyang/"><![CDATA[<p>【摘要】首先安装Flatpak，并使用它安装fcitx5 and rime： sudo apt install flatpak flatpak remote-add –user flathub https://flathub.org/repo/flathub.flatpakrepo flatpak ins <a href="https://www.cnblogs.com/yang-ding/p/19006321" target="_blank">阅读全文</a></p>]]></content><author><name></name></author><summary type="html"><![CDATA[首先安装Flatpak，并使用它安装fcitx5 and rime： sudo apt install flatpak flatpak remote-add --user flathub https://flathub.org/repo/flathub.flatpakrepo flatpak ins]]></summary></entry><entry><title type="html">typora主题美化——代码块颜色修改，标题颜色修改 - dingyang</title><link href="https://sonne-ding.github.io/blog/2023/typora-dingyang/" rel="alternate" type="text/html" title="typora主题美化——代码块颜色修改，标题颜色修改 - dingyang"/><published>2023-04-20T09:25:00+00:00</published><updated>2023-04-20T09:25:00+00:00</updated><id>https://sonne-ding.github.io/blog/2023/typora---dingyang</id><content type="html" xml:base="https://sonne-ding.github.io/blog/2023/typora-dingyang/"><![CDATA[<p>【摘要】typora的GitHub主题是默认主题，也是最符合我的审美的主题。但是仍然有几个小地方不能让我满意： 一级标题和二级标题不够明显 代码块是白色背景，不好看 于是基于官网给的部分代码做了，做了一点小的修改，最终效果如下 版本1： 版本2： 微调github.css主题方法： 1. 打开Theme文件 <a href="https://www.cnblogs.com/yang-ding/p/17337555.html" target="_blank">阅读全文</a></p>]]></content><author><name></name></author><summary type="html"><![CDATA[typora的GitHub主题是默认主题，也是最符合我的审美的主题。但是仍然有几个小地方不能让我满意： 一级标题和二级标题不够明显 代码块是白色背景，不好看 于是基于官网给的部分代码做了，做了一点小的修改，最终效果如下 版本1： 版本2： 微调github.css主题方法： 1. 打开Theme文件]]></summary></entry><entry><title type="html">倒位序算法（C#实现） - dingyang</title><link href="https://sonne-ding.github.io/blog/2022/c-dingyang/" rel="alternate" type="text/html" title="倒位序算法（C#实现） - dingyang"/><published>2022-11-04T11:10:00+00:00</published><updated>2022-11-04T11:10:00+00:00</updated><id>https://sonne-ding.github.io/blog/2022/c---dingyang</id><content type="html" xml:base="https://sonne-ding.github.io/blog/2022/c-dingyang/"><![CDATA[<table> <tbody> <tr> <td>【摘要】倒位序算法（C#实现）</td> <td>原序数（十进制）</td> <td>原序数（二进制）</td> <td>倒位序（二进制）</td> <td>倒位序（十进制）</td> <td> </td> <td> </td> <td> </td> <td> </td> <td> </td> <td> </td> <td>0</td> <td>000</td> <td>000</td> <td>0</td> <td> </td> <td>1</td> <td>001</td> <td>100</td> <td>4</td> <td> </td> <td>2</td> <td>010</td> <td>010</td> <td>3</td> <td> </td> <td>3</td> <td>011</td> <td>110 <a href="https://www.cnblogs.com/yang-ding/p/16858851.html" target="_blank">阅读全文</a></td> </tr> </tbody> </table>]]></content><author><name></name></author><summary type="html"><![CDATA[倒位序算法（C#实现） | 原序数（十进制） | 原序数（二进制） | 倒位序（二进制） | 倒位序（十进制） | | | | | | | 0 | 000 | 000 | 0 | | 1 | 001 | 100 | 4 | | 2 | 010 | 010 | 3 | | 3 | 011 | 110]]></summary></entry><entry><title type="html">对CART决策树剪枝过程的理解 - dingyang</title><link href="https://sonne-ding.github.io/blog/2022/cart-dingyang/" rel="alternate" type="text/html" title="对CART决策树剪枝过程的理解 - dingyang"/><published>2022-10-19T02:56:00+00:00</published><updated>2022-10-19T02:56:00+00:00</updated><id>https://sonne-ding.github.io/blog/2022/cart---dingyang</id><content type="html" xml:base="https://sonne-ding.github.io/blog/2022/cart-dingyang/"><![CDATA[<p>【摘要】对CART决策树剪枝过程的理解 前言：CART决策树生成的过程比较好理解，但是剪枝的过程看了好几遍才看明白，故写出下文，供同样困惑的朋友参考。下文不涉及复杂严密的数学推导，以辅助理解为主。 一. 损失函数的定义方法 CART的损失函数用的是下式： $$ C_\alpha(T)=C(T)+\alpha <a href="https://www.cnblogs.com/yang-ding/p/16805491.html" target="_blank">阅读全文</a></p>]]></content><author><name></name></author><summary type="html"><![CDATA[对CART决策树剪枝过程的理解 前言：CART决策树生成的过程比较好理解，但是剪枝的过程看了好几遍才看明白，故写出下文，供同样困惑的朋友参考。下文不涉及复杂严密的数学推导，以辅助理解为主。 一. 损失函数的定义方法 CART的损失函数用的是下式： $$ C_\alpha(T)=C(T)+\alpha]]></summary></entry><entry><title type="html">拉格朗日插值原理及实现（Python, Matlab） - dingyang</title><link href="https://sonne-ding.github.io/blog/2022/python-matlab-dingyang/" rel="alternate" type="text/html" title="拉格朗日插值原理及实现（Python, Matlab） - dingyang"/><published>2022-09-25T08:58:00+00:00</published><updated>2022-09-25T08:58:00+00:00</updated><id>https://sonne-ding.github.io/blog/2022/python-matlab---dingyang</id><content type="html" xml:base="https://sonne-ding.github.io/blog/2022/python-matlab-dingyang/"><![CDATA[<p>【摘要】拉格朗日插值原理及实现（Python, Matlab） 目录拉格朗日插值原理及实现（Python, Matlab）一. 前言二. 3种形式的Lagrange插值函数推导1. 原始形态的Lagrange插值2. 第一形式Lagrange插值3. 第二形式的Lagrange插值（重心插值公式）三. 利用 <a href="https://www.cnblogs.com/yang-ding/p/16728202.html" target="_blank">阅读全文</a></p>]]></content><author><name></name></author><summary type="html"><![CDATA[拉格朗日插值原理及实现（Python, Matlab） 目录拉格朗日插值原理及实现（Python, Matlab）一. 前言二. 3种形式的Lagrange插值函数推导1. 原始形态的Lagrange插值2. 第一形式Lagrange插值3. 第二形式的Lagrange插值（重心插值公式）三. 利用]]></summary></entry><entry><title type="html">证明矩阵的迹等于特征值之和，矩阵的行列式等于特征值的乘积 - dingyang</title><link href="https://sonne-ding.github.io/blog/2022/dingyang/" rel="alternate" type="text/html" title="证明矩阵的迹等于特征值之和，矩阵的行列式等于特征值的乘积 - dingyang"/><published>2022-09-14T03:36:00+00:00</published><updated>2022-09-14T03:36:00+00:00</updated><id>https://sonne-ding.github.io/blog/2022/---dingyang</id><content type="html" xml:base="https://sonne-ding.github.io/blog/2022/dingyang/"><![CDATA[<p>【摘要】证明矩阵的迹等于特征值之和，矩阵的行列式等于特征值的乘积 矩阵的特征值有以下性质： 设n阶矩阵$M=(m_{ij})_{n\times n}$的全部特征值为$\lambda _1,\lambda _2,\cdots ,\lambda _n$，则有 性质1:$\lambda _1 \lambda _2 <a href="https://www.cnblogs.com/yang-ding/p/16692486.html" target="_blank">阅读全文</a></p>]]></content><author><name></name></author><summary type="html"><![CDATA[证明矩阵的迹等于特征值之和，矩阵的行列式等于特征值的乘积 矩阵的特征值有以下性质： 设n阶矩阵$M=(m_{ij})_{n\times n}$的全部特征值为$\lambda _1,\lambda _2,\cdots ,\lambda _n$，则有 性质1:$\lambda _1 \lambda _2]]></summary></entry><entry><title type="html">NI数据采集卡上位机设计（Labview） - dingyang</title><link href="https://sonne-ding.github.io/blog/2022/nilabview-dingyang/" rel="alternate" type="text/html" title="NI数据采集卡上位机设计（Labview） - dingyang"/><published>2022-08-25T06:57:00+00:00</published><updated>2022-08-25T06:57:00+00:00</updated><id>https://sonne-ding.github.io/blog/2022/nilabview---dingyang</id><content type="html" xml:base="https://sonne-ding.github.io/blog/2022/nilabview-dingyang/"><![CDATA[<p>【摘要】NI数据采集卡上位机设计（Labview） 本文设计的上位机主要有以下特点： 使用NI DAQmx 函数套件读取NI公司数据采集卡内容； 利用XY图绘图，实现了波形大小可调且X轴标签合理对应（波形图表数据缓存区无法在程序面板进行调节，运行过程中无法调节波形大小；波形图可通过传入数据大小调节波形大小， <a href="https://www.cnblogs.com/yang-ding/p/16624283.html" target="_blank">阅读全文</a></p>]]></content><author><name></name></author><summary type="html"><![CDATA[NI数据采集卡上位机设计（Labview） 本文设计的上位机主要有以下特点： 使用NI DAQmx 函数套件读取NI公司数据采集卡内容； 利用XY图绘图，实现了波形大小可调且X轴标签合理对应（波形图表数据缓存区无法在程序面板进行调节，运行过程中无法调节波形大小；波形图可通过传入数据大小调节波形大小，]]></summary></entry><entry><title type="html">C#实现FFT（递归法） - dingyang</title><link href="https://sonne-ding.github.io/blog/2022/cfft-dingyang/" rel="alternate" type="text/html" title="C#实现FFT（递归法） - dingyang"/><published>2022-07-11T04:48:00+00:00</published><updated>2022-07-11T04:48:00+00:00</updated><id>https://sonne-ding.github.io/blog/2022/cfft---dingyang</id><content type="html" xml:base="https://sonne-ding.github.io/blog/2022/cfft-dingyang/"><![CDATA[<p>【摘要】C#实现FFT（递归法） 1. C#实现复数类 我们在进行信号分析的时候，难免会使用到复数。但是遗憾的是，C#没有自带的复数类，以下提供了一种复数类的构建方法。 复数相比于实数，可以理解为一个二维数，构建复数类，我们需要实现以下这些内容： 复数实部与虚部的属性 复数与复数的加减乘除运算 复数与实数的 <a href="https://www.cnblogs.com/yang-ding/p/16466018.html" target="_blank">阅读全文</a></p>]]></content><author><name></name></author><summary type="html"><![CDATA[C#实现FFT（递归法） 1. C#实现复数类 我们在进行信号分析的时候，难免会使用到复数。但是遗憾的是，C#没有自带的复数类，以下提供了一种复数类的构建方法。 复数相比于实数，可以理解为一个二维数，构建复数类，我们需要实现以下这些内容： 复数实部与虚部的属性 复数与复数的加减乘除运算 复数与实数的]]></summary></entry><entry><title type="html">Markdown常用语法 - dingyang</title><link href="https://sonne-ding.github.io/blog/2022/markdown-dingyang/" rel="alternate" type="text/html" title="Markdown常用语法 - dingyang"/><published>2022-07-10T01:33:00+00:00</published><updated>2022-07-10T01:33:00+00:00</updated><id>https://sonne-ding.github.io/blog/2022/markdown---dingyang</id><content type="html" xml:base="https://sonne-ding.github.io/blog/2022/markdown-dingyang/"><![CDATA[<p>【摘要】一、标题 使用n个“#”表示n级标题。 #一级标题 ##二级标题 使用“-”or"="三个以上作为划分，同时上一行作为标题。 或 二、段落 斜体: 斜体 or 斜体； <em>斜体</em> or <em>斜体</em> 粗体: 粗体； <strong>粗体</strong> 粗斜体: 粗斜体； <strong><em>粗斜体</em></strong> 删除线: <del>删除</del>； ~~删除~ <a href="https://www.cnblogs.com/yang-ding/p/16462584.html" target="_blank">阅读全文</a></p>]]></content><author><name></name></author><summary type="html"><![CDATA[一、标题 使用n个“#”表示n级标题。 #一级标题 ##二级标题 使用“-”or&quot;=&quot;三个以上作为划分，同时上一行作为标题。 或 二、段落 斜体: 斜体 or 斜体； *斜体* or _斜体_ 粗体: 粗体； **粗体** 粗斜体: 粗斜体； ***粗斜体*** 删除线: ~~删除~~； ~~删除~]]></summary></entry><entry><title type="html">从傅里叶级数（Fourier series）到离散傅里叶变换（Discrete Fourier transform） - dingyang</title><link href="https://sonne-ding.github.io/blog/2022/fourier-seriesdiscrete-fourier-transform-dingyang/" rel="alternate" type="text/html" title="从傅里叶级数（Fourier series）到离散傅里叶变换（Discrete Fourier transform） - dingyang"/><published>2022-07-09T14:20:00+00:00</published><updated>2022-07-09T14:20:00+00:00</updated><id>https://sonne-ding.github.io/blog/2022/fourier-seriesdiscrete-fourier-transform---dingyang</id><content type="html" xml:base="https://sonne-ding.github.io/blog/2022/fourier-seriesdiscrete-fourier-transform-dingyang/"><![CDATA[<p>【摘要】从傅里叶级数（Fourier series）到离散傅里叶变换（Discrete Fourier transform） 一. 傅里叶级数（FS） 首先从最直观的开始，我们有一个信号$x(t)$（满足Dirichelet条件），==先假设它是周期的==，为了研究它，我们使用级数将之展开，展开方法如下 $ <a href="https://www.cnblogs.com/yang-ding/p/15925430.html" target="_blank">阅读全文</a></p>]]></content><author><name></name></author><summary type="html"><![CDATA[从傅里叶级数（Fourier series）到离散傅里叶变换（Discrete Fourier transform） 一. 傅里叶级数（FS） 首先从最直观的开始，我们有一个信号$x(t)$（满足Dirichelet条件），==先假设它是周期的==，为了研究它，我们使用级数将之展开，展开方法如下 $]]></summary></entry></feed>